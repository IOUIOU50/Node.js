# Node.js 소개

## Node.js란?

Node.js에 필요한 키워드는 다음과 같습니다.

1. 이벤트 기반 & 비동기 처리
1. 싱글 쓰레드
1. 이벤트 루프

### 이벤트 기반의 비동기 I/O처리

주제를 설명하기 전, `Blocking`문제에 대해 짚고 넘어가겠습니다.

우리는, **클라이언트-서버간 데이터를 주고받아 클라이언트의 요청을 처리하는 시스템**을 개발하고 있다고 가정하겠습니다.  
만약, 우리는 이 절차를 해결하기위한 획기적인 아이디어 없이, 보통의 일반적인 프로그래밍을 수행한다고 하면 다음과 같은 절차를 거치게 될 것입니다.

  1. 사용자 요청에 대해 클라이언트 시스템이 서버로 request
  1. 서버는 클라이언트로부터 받은 요청을 처리하고 클라이언트로 response
  1. 서버로부터 요청한 내용을 받은 클라이언트는 해당 데이터를 가공하여 사용자에게 제공

저는 이러한 프로시저를 **순차적 프로그래밍**이라고 칭하겠습니다.  
(사실 순차적 프로그래밍은 더 많은 포괄적인 개념이 들어가야하지만, 이 단계에서는 생략하도록 하겠습니다.)

여기서, 두 번째 단계, response에 집중해보겠습니다.

클라이언트는 서버에 어떠한 데이터를 요청합니다. 서버는 요청한 내용을 처리합니다.  
이때, 서버가 데이터를 response하기까지 클라이언트는 어떤 것을 할 수 있을까요?

이 방법에서 클라이언트는 **아무런 동작도 수행할 수 없습니다.**  
마치 `break`없는 수억개의 반복문을 기다리는 것처럼 말이죠.

우리는 이렇게 어떠한 데이터를 요청하고, 받아오기까지 기다리는 것 외에 아무것도 수행할 수 없는 것을 `Blocking`이라고 합니다.

이러한 Blocking으로 인해 나타나는 문제는 당연하게 시스템의 효율성 측면에서 매우 떨어집니다. 가용할 수 있는 시스템 자원이 존재함에도 사용하지 못하기 때문이죠.

Node.js도 클라이언트-서버 통신을 위한 프레임워크입니다.  
효율적인 서버 통신을 위해 이 문제는 반드시 해결해야하죠.  
Node.js는 Blocking문제를 해결하기 위해 call back방식을 채택했습니다.  
(다른 법으로 `Future`라는 개념이 있습니다. 이는 제가 정리하여 나중에 링크로 추가하도록 하겠습니다.)

싱글 쓰레드를 가진 Node.js에서 작업 요청이 들어오면 작업 처리에 대한 응답을 기다리지 않고, 바로 다음 작업을 실행해 버립니다. 대신 I/O 작업이 종료되면 이벤트를 발생시키고 이 이벤트는 해당 프로세스의 이벤트큐에 등록되게 됩니다. 노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지하여 해당 이벤트 시 수행하여야 할 작업을 실행하게 됩니다.

정리하자면, Node.js는 다음과 같은 작업 처리 과정을 거칩니다.

 1. 클라이언트 -> 서버 요청. 이 때 서버에 요청한 작업이 끝나면 수행해야 할 내역도 같이 등록
 1. 서버는 요청받은 작업을 싱글쓰레드로 처리. 
 1. 클라이언트는 서버에 요청한 작업과 관계 없는 다른 작업을 수행할 수 있게 됨
 1. 서버는 요청받은 작업 처리가 끝나면 함께 전달받은 콜백함수를 수행

